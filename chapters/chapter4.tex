
\ifdraft{\color{green}}{}\chapter{Desenvolvimento da Aplicação}

A criação do protótipo desse sistema foi o ponto principal desse trabalho, pois os objetivo foi oferecer opção para substituir \textit{softwares} que vêm sendo utilizados atualmente por um prático, atual, acessível e com o código disponível para que possa ser corrigido e melhorado. Essencialmente a aplicação foi desenvolvida em linguagens Web, o JavaScript sendo a linguagem de programação, HTML como linguagem de marcação e CSS como estilização.

Nesse protótipo buscou-se eliminar algumas deficiências básica que existem em ferramentas similares, por exemplo funcionalidade de desfazer durante a edição, pois essas podem fazer com que o seu uso seja desgastante e desanimador. Como mencionado nas limitações a inclusão de funcionalidades que poderiam estar disponíveis ficarão como sugestões, algumas delas são encontradas por exemplo em Ambientes Integrados de Programação, comumente utilizada em outras linguagens.

\begin{figure}[h]
  \ifdraft{\color{green}}{}\caption{\ifdraft{\color{green}}{}Interpretador proposto}\label{fig:analisador}
  \centering
\includegraphics[width=\textwidth,height=10cm,keepaspectratio]{figures/interpretador-proposto.pdf}
  \caption*{\ifdraft{\color{green}}{}\footnotesize Fonte: Produção do autor, baseado em \citeonline{esmin1998}.}
\end{figure}

Inclusive há caso em que a ferramenta inicialmente utilizada não é capaz de executar alguns algoritmos mais avançados. E isto leva a necessidade do uso de outro software na mesma disciplina até com possivelmente uma nova linguagem (por exemplo a linguagem de programação C ou C++), devido a está necessidade alguns educadores optam por esta sendo a única ferramenta utilizada, ignorando linguagem Portugol. Espera-se que diferente o UAL essa limitação possa realmente ser concluída em trabalho futuros, conforme proposto nas conclusões.

\section{Levantamento de Requisitos}

% NOTE Seguindo o modelo de \citeonline{silva2013} de um AVA

O desenvolvimento de \textit{software} antes de iniciar a códificação algumas esta[as são esperadas e recomendadas para maior acertividade (qualidade, orçamento, prazos). Análise requisitos prioriza e classifica os pontos aos quais a aplicação se pretende solucionar.

\subsection{Requisitos Funcionais}

\begin{enumerate}

\item Permitir ao aluno edição de código

\item Permitir ao aluno abrir arquivos de texto

\item Permitir salvar o arquivo alterado

\item Permitir visualizar a simulação do programa

\end{enumerate}

\subsection{Requisitos Não Funcionais}

\begin{enumerate}

\item O programa deve prezar pelo menor tamanho possível nos arquivos

\item O sistema deverá rodar em navegador (\textit{browser}) moderno

\item Deverá ter interface minimalista, mas visualmente agradável

\item Ser acessível mesmo que desconectado da internet

\end{enumerate}

\begin{figure}[h]
  \caption{\ifdraft{\color{green}}{}Caso de uso Aluno}\label{fig:usecase}
  \centering
\includegraphics[width=.8\textwidth,height=10cm,keepaspectratio]{figures/caso-de-uso.pdf}
  \caption*{\ifdraft{\color{green}}{}\footnotesize Fonte: Produção do autor.}
\end{figure}

\section{Editor de Código ACE}

No modelo para navegador já existem editores de código fonte de linguagens de programação,dos mais utilizados temos ACE\nocite{ace} e o CodeMirror\nocite{codemirror}, optado pelo primeiro pois em análise entendeu-se como sendo mais prático para o uso e criação do modelo da linguagem. Considerou-se a criação do modelo gramatical para destaque da sintaxe como dificuldade relativamente baixa.

Em tecnologia há os chamados \textit{playground} (área de lazer), que são chamadas áreas para experimentações com determinada ferramenta ou tecnologia. No caso do editor ACE é disponibilizado uma ``pia de cozinha'' (\textit{Kitchen Sink}\nocite{kitchensink}) conforme figura \ref{fig:ace-kitchensink}, onde o editor embutido pode ser modificado através de um menu lateral quanto a linguagem ou tema e outras de suas várias opções.

\begin{figure}[h]
  \caption{\ifdraft{\color{green}}{}Ace \textit{Kitchen Sink}}\label{fig:ace-kitchensink}
  \centering
\includegraphics[width=\textwidth,keepaspectratio]{figures/ace-kitchensink.pdf}
  \caption*{\ifdraft{\color{green}}{}\footnotesize Fonte: Captura de tela da parte visível no navegador.}
\end{figure}

Inicialmente as funcionalidades pretendidas são todas supridas e outra mais levam a esta ser uma opção útil para evolução da aplicação em trabalhos futuros. Ignorando as duas que dizem respeito ao destacamento de sintaxe em mais de 110 linguagens (porem custumizável, que permitiu adicionar UAL) e mais de 20 temas (também personalizado apra o preto com negrito nas palavras reservadas, como o Editor UAL), as outras seguem listadas:

\begin{itemize}

\item Identação automática;
\item Permite documentos com muitas linhas;
\item Atalhos de teclado personalizáveis;
\item Localizar e substituir, podendo utilizar expressões regulares;
\item Alternar entre tabulação suave (espaços) ou tabulação real;
\item Exibir caracteres ocultos;
\item Arrastar e soltar utilizando mouse;
\item Limitação de colunas no texto, com quebra;
\item Retrair ou expantir código/
\item Cursores e seleção múltiplas;
\item Checagem em tempo real para algumas linguagens/
\item Funcionalidade de recortar, copiar e colar.

\end{itemize}

\section{Acorn}

Para resultar na árvore sintática encontrou-se o ACORN\nocite{acorn} um parser já escrito em JavaScript. De modo trabalhoso foi necessário adaptar o código fonte para compreender a estrutura do algorítmos proposto, principalmente devido à não utilização de parênteses para o comando de impressão em tela na linguagem UAL.

\begin{quadro}[h]
\centering
  \caption{Árvore sintática gerada pelo Acorn modificado}\label{qua:compare-tools}
\begin{lstlisting}[style=json,frame=single]
{
  "type": "Program",
  "start": 0,
  "end": 61,
  "body": [
    {
      "type": "PrintStatement",
      "start": 19,
      "end": 53,
      "print": {
        "type": "CallPrint",
        "start": 27,
        "end": 52,
        "arguments": {
          "type": "Literal",
          "start": 27,
          "end": 52,
          "value": "Aprendendo Algoritmo!!!",
          "raw": "\"Aprendendo Algoritmo!!!\""
        }
      }
    }
  ],
  "id": {
    "type": "Identifier",
    "start": 5,
    "end": 16,
    "name": "algoritmo11"
  }
}
\end{lstlisting}
  \caption*{\ifdraft{\color{green}}{}\footnotesize Fonte: Produção do autor.}
\end{quadro}

\section{JS-Interpreter}

Como saída o interpretada o JS-Interpreter\nocite{jsinterpreter} foi encontrado como a única opção. Ele já se utiliza do mesmo ACORN mencionado acima e interpreta a própria linguagem JavaScript. Pelo mesmo motivo citado acima, falta de parênteses no comando, se tornou uma tarefa um tanto dispendiosa fazer com que ele se adaptasse ao modelo.

\begin{figure}[h]
  \caption{Esquemático do Interpretador}\label{fig:flux}
  \centering
  \setlength{\fboxsep}{0pt}%
\setlength{\fboxrule}{1pt}%
\fbox{\includegraphics[width=10cm,height=10cm,keepaspectratio]{figures/bizual-interpretador.pdf}}
  \caption*{\footnotesize Fonte: Produção do autor.}
\end{figure}

\section{Interface Gráfica}

Como interface gráfica foi mantido o mínimo necessário. Somente o editor de texto e um botão para executar. Foram visualizadas renderizações e tamanhos de telas variados, computadores (Figura \ref{fig:ui-pc}), tablets, smartphones (Figura \ref{fig:ui-phone}), etc. Seguindo conceitos do Google Material Design foi adicionada uma barra no topo como botão para menu o nome da aplicação, denominada Bizu, e um botão flutuante no canto inferior direito como ícone ``play'' para a execução do algoritmo.

\begin{figure}[h]
  \caption{Interface Desktop}\label{fig:ui-pc}
  \centering
  \setlength{\fboxsep}{0pt}%
\setlength{\fboxrule}{1pt}%
\fbox{\includegraphics[width=.9\textwidth,keepaspectratio]{figures/bizual-desktop.pdf}}
  \caption*{\footnotesize Fonte: Produção do autor.}
\end{figure}

De acordo com o \citeonline{dicionarioinformal2016} a gíria ``bizu'' teve origem em quartéis militares, onde os experientes sussurravam dicas para os novatos. Os superiores de longe ouviam aquela onomatopéia característica de cochicho ``bzbzbzu'', dando origem ao termo. A escolha do nome se deve a partir da palavra bizu adicionada a sigla da sintaxe: resultando em ``BizUAL'', nesta grafia.

%\begin{figure}[h]
%  \caption{Interface Smartphone}\label{fig:ui-phone}
%  \centering
%  \setlength{\fboxsep}{0pt}%
%\setlength{\fboxrule}{1pt}%
%\fbox{\includegraphics[width=10cm,height=10cm,keepaspectratio]{figures/bizual-smartphone.pdf}}
%  \caption*{\footnotesize Fonte: Produção do autor.}
%\end{figure}

Facilitando a tarefa de construção da interface foi utilizada a biblioteca Material Design Lite (MDL)\nocite{mdl} disponibilizada oficialmente pelo Google. As cores foram escolhidas pela funcionalidade disponível no site da biblioteca.

Foi utilizado a funcionalidade \textit{app cache} a partir de um arquivo manifesto listando o conteúdo que o navegador deve guardar cópia local. Podendo assim ter a internet desconectada após o primeiro acesso que a aplicação continuará acessível.

Todo o código foi desenvolvido em repositório disponível no github e quando concluído em sua versão mínima movido para seu destino final e podendo ser acessado.\nocite{bizual}\color{black}

\section{Acesso \textit{Offline}}

%Ainda não há aderência dentre os desenvolvedores, bem porque ainda não foi finalizada sua especificação. Além de que a primeira tentativa de criar o \textit{AppCache} como solução solução teve um resultado ruim, mas agora com os \textit{Service Workers} a esperança foi renovada.
%
%\subsection{\textit{AppCache}}
%
%Desenvolvido pela consórcio criado para o desenvolvimento do HTML5 veio suprir a necessidade de armazenamento avançado de arquivos utilizados na aplicação web. Sua compatibilidade foi seu adicionada aos navegadores durante sua criação, na tabela \ref{tab:appcache-compatibility}  Porém apesar de simples sua específicação extensa e confusa além de muitas limitações conhecidas levou a criaçao de uma melhor solução. Essa fucionalidade permanece compatível mas é recomendado sua não utilização por motivo da futura remoção dela nos navegadores.

\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

%\begin{table}[h]
%\centering
%  \caption{Suporte à \textit{AppCache} pelos navegadores}\label{tab:appcache-compatibility}
%\begin{tabular}{ C{46pt} | C{46pt} | C{46pt} | C{46pt} | C{46pt} | C{46pt} | C{46pt} }\hline
%IE & Firefox & Safari & Chrome & Opera & iPhone & Android \\ \hline
% & 3.5+ & 4.0+ & 5.0+ & 10.6+ & 2.1+ & 2.0+ \\ \hline
%\end{tabular}
%  \caption*{\ifdraft{\color{green}}{}\footnotesize Fonte: ``Aplicações Web Offline - Dive into HTML5'' por \citeonline{diveintohtml5}.}
%\end{table}
%
%Mesmo tento sido depreciada cabe, até por comparação, explicar seu funcionamento. Ela utiliza, como explica \citeonline{diveintohtml5}, apenas um arquivo de texto onde lista todos os arquivos de imagem, estilização, scripts de programação, entre outros (ver quadro \ref{qua:html-root}). Esse arquivo declarado manifesto deve ser desclarado como atributo no etiqueta de abertura do html (veja quadro  \ref{qua:cache-appcache}).
%
%\let\origthelstnumber\thelstnumber
%\makeatletter
%\newcommand*\Suppressnumber{%
%  \lst@AddToHook{OnNewLine}{%
%    \let\thelstnumber\relax%
%     \advance\c@lstnumber-\@ne\relax%
%    }%
%}
%
%\newcommand*\Reactivatenumber[1]{%
%  \lst@AddToHook{OnNewLine}{%
%   \let\thelstnumber\origthelstnumber%
%   \setcounter{lstnumber}{\numexpr#1-1\relax}%
%   %\advance\c@lstnumber\@ne\relax%
%  }%
%}
%
%\makeatother
%
%\begin{quadro}[h]
%\centering
%  \caption{Código HTML ignorando cabeçalho e corpo}\label{qua:html-root}
%\begin{lstlisting}[numbers=left,escapeinside=\$\$,frame=single]
%<!DOCTYPE html>
%<html lang="pt-BR" manifest="cache.appcache">
%  <head>$\Suppressnumber$
%    (...)$\Reactivatenumber{16}$
%  </head>$\Reactivatenumber{17}$
%  <body>$\Suppressnumber$
%    (...)
%  </body>$\Reactivatenumber{51}$
%</html>
%
%\end{lstlisting}
%  \caption*{\ifdraft{\color{green}}{}\footnotesize Fonte: Produção do autor.}
%\end{quadro}
%
%\begin{quadro}[h]
%\centering
%  \caption{Arquivo de manifesto \textit{appcache}}\label{qua:cache-appcache}
%\begin{lstlisting}[numbers=left,frame=single]
%CACHE MANIFEST
%
%# Updated: 2016-11-90T01:27:00-02:00
%
%# Main page
%
%# CSS
%style/material.blue-orange.min.css
%style/main.css
%
%# Fonts
%style/fonts/material-icons.css
%style/fonts/MaterialIcons-Regular.eot
%style/fonts/MaterialIcons-Regular.woff
%style/fonts/MaterialIcons-Regular.woff2
%style/fonts/MaterialIcons-Regular.ttf
%
%# Other resources
%
%# JavaScript
%js/material.min.js
%js/aceual.js
%
%favicon.ico
%
%NETWORK:
%*
%
%\end{lstlisting}
%  \caption*{\ifdraft{\color{green}}{}\footnotesize Fonte: Produção do autor.}
%\end{quadro}

Com auxílio de \textbf{\textit{Service Workers}} (SW) é possível resolver a navegação \textit{offline}. Está sendo desenvolvido, como explica \citeonline{swfirstdraft}, por um esforço colaborativo entre grandes empresas como Google, Mozilla e outras, sua implementação tem sido constante principalmente nos navegadores Chrome e Firefox. Realmente excitante para os interessados na competição entre \textit{web} e aplicações nativas nos sistemas operacionais.

\lstdefinestyle{swreg}
{
  morestring  = [s]{<script}{script>},
  basicstyle  = \small\ttfamily\color{darkgrey},
  stringstyle = \bfseries\color{black},
}

\begin{quadro}[h]
\centering
  \caption{HTML destacando o registro do SW}\label{qua:swregister}
\begin{lstlisting}[style=swreg,frame=single]
<!DOCTYPE html>
<html>
  <head>
    (...)
  <body>
    (...)a
    <script>
      if (navigator.serviceWorker !== undefined) {
        navigator.serviceWorker.register('sw.js');
      }
    </script>
</html>

\end{lstlisting}
  \caption*{\ifdraft{\color{green}}{}\footnotesize Fonte: Produção do autor.}
\end{quadro}

Sua implementação no modo mais básico em uma aplicação de página única pode ser considerada simples. Porém sua versatilidade e aplicabilidade é incrivelmente mais extensa. Inicialmente é necessário informar ao navegar o arquivo JavaScript que serão o controlador, se comportando como se fosse um \textit{proxy} local. Para isso utiliza-se o comando de registro (conforme quadro \ref{qua:swregister}), após testar se o navegador é compatível.
%
%\lstdefinestyle{swjs}
%{
%  morestring  = [s]{`use}{strict';},
%  stringstyle = \color{darkgrey},
%  keywordstyle = \color{darkgrey},
%  commentstyle = \color{darkgrey},
%  morecomment  = [l]{/*},
%}
%style=swjs,
\begin{quadro}[h]
\centering
  \caption{Conteúdo do arquivo SW}\label{qua:swjs}
\begin{lstlisting}[frame=single]
self.oninstall = function (event) {
  event.waitUntil(
    caches.open(`bizual-static-v1').then(function (cache) {
      return cache.addAll([
        `./',
        `css/all.css',
        `js/material.min.js',
        `js/aceual.js',
        `imgs/icon.png'
      ]);
    })
  );
};

self.onfetch = function (event) {
  event.respondWith(
    caches.match(event.request)
  );
};

\end{lstlisting}
  \caption*{\ifdraft{\color{green}}{}\footnotesize Fonte: Produção do autor.}
\end{quadro}

Dentro do arquivo \texttt{sw.js}, notável em quadro \ref{qua:swjs}, constam dois eventos: um de instalação para quando o navegador instala (\textbf{\textit{install}}) de acordo com o registro e outra para captura de ação de rede (\textbf{\textit{fetch}}), onde iria naturalmente requisitar determinado recurso. No evento de instalação lista os arquivos a serem armazenados e no de rede indica a utilizar os arquivos armazenados.

\begin{table}[h]
\centering
  \caption{Suporte à \textit{ServiceWorkers} pelos navegadores}\label{tab:swcompatibility}
\begin{tabular}{ C{46pt} | C{46pt} | C{46pt} | C{46pt} | C{46pt} | C{46pt} | C{46pt} }\hline
Edge & Firefox & Chrome & Safari & Opera & iOS & Android \\ \hline
 & 49+ & 49+ &  & 41+ &  & 5.0+ \\ \hline
\end{tabular}
  \caption*{\ifdraft{\color{green}}{}\footnotesize Fonte: Produção do autor, baseando em \citeonline{swcaniuse}.}
\end{table}

Durante o trabalho tem utilizada a denominação ``navegador moderno'' para nosso estudo são navegadores que apostam em novas tecnologia que estejam surgindo. Normalmente podem ser considerados o Google Chrome, Mozilla Firefox e Opera. A Microsoft vêm flexibilidade essas adoções nas últimas versões e do seu subistitudo Edge, porém em tecnologia ainda rascunho ela escolhe por aguardar maior definição e maturidade. A tabela \ref{tab:swcompatibility} apresenta como está, mesmo que parcial, essa compatibilidade. Resaltando o quão recente é essa adoção, as versões lançadas somente neste ano como estáveis entre 9 de setembro e 23 de outubro, são nesses navegadores a primeira implementação ocorrida. Apenas o Google Chrome para \textit{desktop} possui compabilidade nas versões anteriores, desde 2 de maio também deste ano.

Algumas observações são necessárias sobre a \ref{tab:swcompatibility}, o Microsoft \textbf{Edge} está nessa compatibilidade como ``em desenvolvimento'', e o Internet Explorer (IE) foi intencionamente ignorado por certamente nunca receber essa implementação já que seu desenvolvimento foi descontinua em favor do Edge. O \textbf{Safari} da Apple utiliza motor Webkit e ele está com a situação, quanto essa compatibilidade, como ``sob consideração''. E o \textbf{Android} 4.4.4 já utilizava WebView do Chrome mas só na 5.0 veio nativa e independente, porém instalar a última versão do Google Chrome para esse sistema operacional \textit{mobile} tem o mesmo efeito, desde WebView ou navegador na versão 53.

\ifdraft{}{
%\section{Ferramentas Utilizadas}

%
%
%\section{Processo Criacional}
%
%\subsection{Git e Github}
%
%\subsection{Node.js e Grunt}
%
%\subsection{SASS}
%
%\subsection{TDD}
%
%\subsection{\textit{Material Design}}
%
%\subsubsection{MDL}
%
%\subsection{Inspirações}
}
